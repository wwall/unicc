<?xml version="1.0" standalone="yes"?>
<generator name="bsl">
    <code_localization />
    <!--
    ****************************************************************************
    Boolean values
    ****************************************************************************
    -->
    <true>true</true>
    <false>false</false>

    <!--
    ****************************************************************************
    Escape sequences
    ****************************************************************************
    -->

    <!-- Backslash must be double-quoted -->
    <escape-sequence for="\" do="\\" />
    <!-- Escape double quotation marks -->
    <escape-sequence for="&#x22;" do="&#x22;&#x22;" />

    <!--
    ****************************************************************************
    Value-stack templates
    ****************************************************************************
    -->

    <vstack_def_type>any</vstack_def_type>
    <vstack_term_type>any</vstack_term_type>
    <vstack_union_att>@@value-type-id</vstack_union_att>
    <vstack_union_def>@@attribute: null, </vstack_union_def>
    <vstack_single>value: null</vstack_single>
    <vstack_union_start>value: {</vstack_union_start>
    <vstack_union_end>}</vstack_union_end>

    <!--
    ****************************************************************************
    Semantic action templates
    ****************************************************************************
    -->

    <action_start>elsif what = @@production-number then &#x0A;&#x09;</action_start>
    <action_end>&#x0A;</action_end>

    <action_single>pcb.stack[ pcb.stack.count() - ( @@offset + 1 ) ].value</action_single>

    <action_union>pcb.stack[ pcb.stack.count() - ( @@offset + 1 ) ].value.@@attribute</action_union>
    <action_lhs_single>pcb.ret</action_lhs_single>
    <action_lhs_union>pcb.ret.@@attribute</action_lhs_union>

    <action_set_lhs>pcb.lhs = @@sym</action_set_lhs>

    <!--
    ****************************************************************************
    Semantic terminal action templates
    ****************************************************************************
    -->

    <scan_action_start>if what = @@production-number then &#x0A;</scan_action_start>
    <scan_action_end>&#x0A;</scan_action_end>

    <scan_action_begin_offset>pcb.buf</scan_action_begin_offset>
    <scan_action_end_offset>pcb.len</scan_action_end_offset>
    <scan_action_ret_single>pcb.tos.value</scan_action_ret_single>
    <scan_action_ret_union>pcb.tos.value.@@attribute</scan_action_ret_union>

    <scan_action_set_symbol>( pcb.sym = @@sym )</scan_action_set_symbol>

    <!--
    ****************************************************************************
    Parse table templates
    ****************************************************************************
    -->

    <defprod>
        <col>value.add(@@production-number);</col>
        <col_sep></col_sep>
    </defprod>

    <acttab>
        <row_start>value.add(new Map);index = value.ubound();</row_start>
        <row_end></row_end>
        <row_sep>&#x0A;&#x09;</row_sep>
        <col>value[index][@@symbol] = new Structure("action, index", @@action, @@index);</col>
        <col_sep></col_sep>
    </acttab>

    <gotab>
        <row_start>value.add(new Map); index = value.ubound();</row_start>
        <row_end></row_end>
        <row_sep>&#x0A;&#x09;</row_sep>
        <col>value[index][@@symbol]= new Structure("action, index",@@action, @@index);</col>
        <col_sep></col_sep>
    </gotab>

    <!--
    ****************************************************************************
    Lexer
    ****************************************************************************
    -->

    <dfa_select>
        <col>value.add(@@machine);</col>
        <col_sep> </col_sep>
    </dfa_select>

    <dfa_char>
        <col>value.add(new Structure("from, to",@@from, @@to));</col>
        <col_sep>&#x0A;&#x09;</col_sep>
    </dfa_char>

    <dfa_trans>
        <col>value.add(@@goto);</col>
        <col_sep></col_sep>
    </dfa_trans>

    <dfa_idx>
        <row_start>value.add(new Array); row_index = value.ubound();</row_start>
        <row_end>&#x0A;&#x09;</row_end>
        <row_sep></row_sep>
        <col>value[row_index].add(@@index);</col>
        <col_sep></col_sep>
    </dfa_idx>

    <dfa_accept>
        <row_start>value.add(new Array); row_index = value.ubound();</row_start>
        <row_end>&#x0A;&#x09;</row_end>
        <row_sep></row_sep>
        <col>value[row_index].add(@@accept);</col>
        <col_sep></col_sep>
    </dfa_accept>

    <!--
    ****************************************************************************
    Symbol and production information tables
    ****************************************************************************
    -->

    <symbols>
        <col>&#x09;value[@@symbol]&#x09;=&#x09;new Structure("whitespace, type, symbolName, lexem, greedy, has_emit, emit", @@whitespace, @@type, "@@symbol-name", @@lexem, @@greedy, not "@@emit" = "", "@@emit");</col>
        <col_sep>&#x0A;</col_sep>
    </symbols>

    <productions>
        <col>&#x09;value[@@production-number]&#x09;=&#x09;new Structure("production, has_emit, emit, length, lhs", "@@production", not "@@emit" = "", "@@emit", @@length, @@lhs);</col>
        <col_sep>&#x0A;</col_sep>
    </productions>

    <!--
    ****************************************************************************
    JavaScript program
    ****************************************************************************
    -->

<file filename="@@basename.bsl">// src parser module was generated by unicc from @@filename.
// DO NOT EDIT src FILE MANUALLY, IT WILL GO AWAY!

#region prologue
@@prologue
#endregion


#region init

#region symbols

function init_symbols()
	value = new Map;
@@symbols

	return value;
endfunction

#endregion

#region productions

function init_productions()
	value = new Map;
@@productions

	return value;
endfunction

#endregion

#region lexer

function init_dfa_select() value = new Array; @@dfa-select return value; endfunction
function init_dfa_trans() value = new Array;  @@dfa-trans return value; endfunction

function init_dfa_index()
	value = new Array; 
	@@dfa-index
	return value; 
endfunction

function init_dfa_accept()
	value = new Array; 
	@@dfa-accept
	return value; 
endfunction

function init_dfa_chars()
	value = new Array; 
	@@dfa-char
	return value; 
endfunction

function init_lexer()
	value = new Structure;
	value.insert("select", init_dfa_select());
	value.insert("index", init_dfa_index());
	value.insert("chars", init_dfa_chars());
	value.insert("transitions", init_dfa_trans());
	value.insert("accept", init_dfa_accept());

	return value;
endfunction

#endregion



#region parser
function init_action_table()
	value = new Array; 
	@@action-table
	return value; 
endfunction

function init_goto_table()
	value = new Array; 
	@@goto-table
	return value; 
endfunction      

function init_default_production() value = new Array; @@default-productions return value; endfunction

function init_parser()
	value = new Structure;
	value.insert("action", init_action_table());
	value.insert("goto", init_goto_table());
	value.insert("default", init_default_production());

	return value;
endfunction

#endregion

function eof()
	return @@eof;
endfunction

function error()
	return @@error;
endfunction

function init()
    value = new Structure;

    value.insert("eof", eof());
    value.insert("error", error());
    value.insert("filename", "@@filename");
    value.insert("goal", @@goal);
    value.insert("goalProduction", @@goal-production);
    value.insert("mode", @@mode);
    value.insert("NumberDFAMachines", @@number-of-dfa-machines);
    value.insert("NumberProductions", @@number-of-productions);
    value.insert("NumberStates", @@number-of-states);
    value.insert("NumberSymbols", @@number-of-symbols);

    value.insert("symbols", init_symbols());
    value.insert("productions", init_productions());
    value.insert("lexer", init_lexer());
    value.insert("parser", init_parser());

    return value;
endfunction

function @@prefixNode(emit, match, children = undefined)
    return new Structure("emit, match, children", emit, match, children);
endfunction

function make_@@prefixParserToken ()
    return new Structure("state, line, column, node, value, symbol", 0, 0, 0, undefined, undefined, undefined);
endfunction

// Defining a custom exception for parse errors
function @@prefixParseError(line, column, expecting) 
    return strTemplate("line - %1, column - %2, expecting - %3", line, column, expecting); 
endfunction

function make_@@prefixParserControlBlock()
	data = new structure;
	data.insert("grammar",init());
        // Stack
        data.insert("stack", new Array);
        data.insert("tos",undefined);

        // Values
        data.insert("ret", undefined);

        // State
        data.insert("act", undefined);
        data.insert("idx", undefined);
        data.insert("lhs", undefined);

        // Lookahead
        data.insert("sym", -1);
        data.insert("old_sym", -1);
        data.insert("len", 0);

        // Lexical analysis
        data.insert("lexem", undefined);
        data.insert("next", undefined);
        data.insert("eof", undefined);
        data.insert("is_eof", false);

        // Input buffering
        data.insert("input", undefined);
        data.insert("buf", "");
        data.insert("offset", 1);     

        // Error handling
        data.insert("error_delay", 3);
        data.insert("error_count", 0);

        data.insert("line", 1);
        data.insert("column", 1);
	
	data.insert("debug", true);

        // User-defined
        @@pcb
    return data;
endfunction

function getTop(pcb)
    return @@top-value;
endfunction

procedure setTop(pcb, value)
    @@top-value = value;
endprocedure

#endregion


#region service

function pop(stack)
    value = stack[stack.ubound()];
    stack.delete(stack.ubound());
    return value;
endfunction

procedure push(stack, value)
    stack.add(value);
endprocedure

#endregion



#region Parser


function @@prefixget_char(pcb) 
	ch = pcb.grammar.eof;
	if( strlen(pcb.input) > 0) then
		ch = mid(pcb.input, 1, 1);
		pcb.input  = mid(pcb.input,2);
	endif;
	
	return ch;
endfunction


function  @@prefixget_input( pcb, offset) 
	if( pcb.is_eof ) then
		return pcb.grammar.eof;
	endif;
	while (offset >= strlen(pcb.buf)) do 
		ch = get_char( pcb);
		if( ch = pcb.grammar.eof ) then
			pcb.is_eof = true;
			return pcb.grammar.eof;
		endif;
		pcb.buf = pcb.buf + ch;
	enddo;
	v = charcode(mid(pcb.buf,offset+1,1));
	//    message(strtemplate("#get_input `%1`, %2, %3, %4", pcb.buf, offset, mid(pcb.buf, offset, 1), v));
	
	return v;
endfunction

function @@prefixclear_input(pcb) 
	if( not strlen(pcb.buf) = 0) then
		// Perform position counting.
		for pos = 0 to pcb.len-1 do
			if( mid(pcb.buf, pos + 1, 1) = chars.CR ) then
				pcb.line = pcb.line +1;
				pcb.column = 0;
			else
				pcb.column = pcb.column +1;
			endif
		enddo;	
		
		pcb.buf = mid(pcb.buf,  pcb.len + 1 );
		
	endif;
	
	pcb.len = 0;
	pcb.sym = -1;
endfunction





procedure lex(pcb) 
        // Perform lexical analysis
        state = 0;
        length = 0;

        machine = ?(pcb.grammar.mode = 0,  pcb.grammar.lexer["select"][pcb.tos.state], 0);
        next = get_input(pcb, length);

        if( next = pcb.grammar.eof) then
            pcb.sym = eof();
            return;
        endif;

        while( state &gt; -1 and not next = pcb.grammar.eof  ) do
            idx = pcb.grammar.lexer["index"][machine][state];
            state = -1;

            while( pcb.grammar.lexer["chars"][idx].from &gt; -1 ) do
                if( next &gt;= pcb.grammar.lexer["chars"][idx].from
                        and next &lt;= pcb.grammar.lexer["chars"][idx].to ) then

                    length = length +1;
                    state = pcb.grammar.lexer["transitions"][idx];

                    if( pcb.grammar.lexer["accept"][machine][state] &gt; 0 ) then
                        pcb.sym = pcb.grammar.lexer["accept"][machine][state] - 1;
                        pcb.len = length;

                        // Test! (??)
                        if( pcb.sym = eof()) then
                            state = -1;
                            break;
                        endif;

                        // Stop if matched symbol should be parsed nongreedy
                        if( not pcb.grammar.symbols[pcb.sym].greedy ) then
                            state = -1;
                            break;
                        endif;
                    endif;

                    next = get_input(pcb, length);
                    break;
                endif;

                idx = idx +1;
            enddo;

        enddo;

	if pcb.debug then
		message(strTemplate("lex sym = %1, len = %2", pcb.sym, pcb.len));
	endif;

endprocedure

function get_sym(pcb) 
        // Get lookahead symbol
        pcb.sym = -1;
        pcb.len = 0;

        // insensitive mode
        if( pcb.grammar.mode = 1 ) then
            while( true ) do
                lex(pcb);

                // check for whitespace
                if( pcb.sym &gt; -1 and 
                    Boolean(pcb.grammar["symbols"][pcb.sym]["is-whitespace"]) ) then
                    clear_input(pcb);
                    continue;
                endif;

                break;
            enddo;
        elsif( pcb.grammar.lexer["select"][pcb.tos.state] &gt; -1 ) then
            lex(pcb);
        elsif( pcb.get_input(pcb, 0) = pcb.eof ) then
            pcb.sym = @@eof;
        endif;
        
        return pcb.sym &gt; -1;
endfunction

function parse(s) 
	
	ERROR	= 0;
	REDUCE	= 1;
	SHIFT	= 2;
	SUCCESS	= 4;
		
	actConst = new Map;
	actConst[ERROR]		= new Structure("shift, reduce", false, false);
	actConst[REDUCE]	= new Structure("shift, reduce", false, true);
	actConst[SHIFT]		= new Structure("shift, reduce", true, false);
	actConst[SHIFT + REDUCE] = new Structure("shift, reduce", true, true);
	actConst[SUCCESS]	= new Structure("shift, reduce", false, false);


        // Start of parse function
        pcb = make_@@prefixParserControlBlock();
        pcb.input = s;
        pcb.act = SHIFT;

        pcb.tos = make_@@prefixParserToken();
        push(pcb.stack, pcb.tos);

        while( true ) do
            //console.log("state = %d", pcb.tos.state);

            // Reduce
            while( actConst[pcb.act].reduce) do
                // Set default left-hand side
                pcb.lhs = pcb.grammar.productions[pcb.idx].lhs;

                //console.log("REDUCE idx = %d, prod = %s", pcb.idx, src.constructor.#grammar["productions"][pcb.idx]["production"]);
                // print("state", pcb.tos.state);

                // Call reduce function
                //console.log("CALL", "_reduce_action_%d" % pcb.idx)
                what = pcb.idx;
                if( true = false) then
                    @@actions
                else
                    // nothing
                endif;

                // Drop right-hand side
                cnodes = null;
                node = null;

			for i = 0 to pcb.grammar.productions[pcb.idx].length - 1 do
				item = pop(pcb.stack);
				
				if( ValueIsFilled(item.node)) then
					if( cnodes = null ) then
						cnodes = new Array;
					endif;
					
					if( typeOf(item.node) = type("Array") ) then
						for each x in item.node do
							cnodes.Add(x);
						enddo;
					else
						cnodes.add(item.node);
					endif;
				endif;
			enddo;

                pcb.tos = pcb.stack[pcb.stack.ubound()];
                pcb.tos.value = pcb.ret;

		if( pcb.grammar.productions[pcb.idx].has_emit ) then
			if pcb.debug then
                    		message(StrTemplate("Handle AST nodes >> %1 = %2", pcb.grammar.productions[pcb.idx].production, pcb.grammar.productions[pcb.idx].emit));
			endif;
			node = @@prefixNode(pcb.grammar.productions[pcb.idx].emit, Undefined, cnodes);
                endif;

                // Goal symbol reduced, and stack is empty?
                if( pcb.lhs = pcb.grammar.goal and pcb.stack.count() = 1 ) then
		pcb.tos.node = ?(ValueIsFilled(node) , node , cnodes);
                    clear_input(pcb);
                    pcb.act = SUCCESS;
                    break;
                endif;

                // Get goto table entry
                pcb.act = pcb.grammar.parser.goto[pcb.tos.state][pcb.lhs].action;
                pcb.idx = pcb.grammar.parser.goto[pcb.tos.state][pcb.lhs].index;

                pcb.tos = make_@@prefixParserToken();
                push(pcb.stack, pcb.tos);

                pcb.tos.symbol = pcb.grammar.symbols[pcb.lhs];
                pcb.tos.state = ?(pcb.act = REDUCE , -1 , pcb.idx);
                pcb.tos.value = pcb.ret;

                pcb.tos.node = ?(valueIsFilled(node) , node , cnodes);
                pcb.tos.value = pcb.ret;

                pcb.tos.line = pcb.line;
                pcb.tos.column = pcb.column;
            enddo;

            if( pcb.act = SUCCESS or pcb.act = ERROR ) then
                break;
            endif;
            // Get next input symbol
            get_sym(pcb);

            //console.log("pcb.sym = %d (%s)", pcb.sym, src.constructor.#grammar["symbols"][pcb.sym]["symbol"]);
            //console.log("pcb.len = %d", pcb.len);

            // Get action table entry
            if(  undefined = pcb.grammar.parser.action[pcb.tos.state][pcb.sym] ) then
                pcb.idx = pcb.grammar.parser.default[pcb.tos.state];
                pcb.act = ?(pcb.idx &gt; -1, REDUCE, ERROR);
            else
                pcb.act = pcb.grammar.parser.action[pcb.tos.state][pcb.sym].action;
                pcb.idx = pcb.grammar.parser.action[pcb.tos.state][pcb.sym].index;
            endif;

            if( pcb.act = ERROR ) then
		errorData = new Array; for each x in pcb.grammar.parser.action[pcb.tos.state] do errorData.Add(StrTemplate("'%1'", pcb.grammar.symbols[x.key].symbolName)); enddo;
                raise ParseError( pcb.line, pcb.column, StrConcat(errorData, " or "));
            endif;

            // Shift
            if( actConst[pcb.act].shift ) then
                //console.log("SHIFT sym = %d (%s)", pcb.sym, src.constructor.#grammar["symbols"][pcb.sym]["symbol"]);

                pcb.tos = make_@@prefixParserToken();
                push(pcb.stack, pcb.tos);

                // Execute scanner actions, if existing.
                what = pcb.idx;
                if( true = false) then
                    @@scan_actions
                endif;

                pcb.tos.state = ?(pcb.act = REDUCE ,  -1 , pcb.idx);
                pcb.tos.symbol = pcb.grammar["symbols"][pcb.sym];

                pcb.tos.line = pcb.line;
                pcb.tos.column = pcb.column;
		setTop(pcb, mid(pcb.buf, 1, pcb.len));

                if( pcb.tos.symbol.has_emit) then
                    pcb.tos.node = Node(pcb.tos.symbol.emit, getTop(pcb));
                endif;

                if( not pcb.sym = pcb.grammar.eof 
			and not pcb.sym = pcb.grammar.error ) then
                    clear_input(pcb);
                    pcb.old_sym = -1
                endif
            endif;
        enddo;

	if( undefined = pcb.ret 
			and not undefined = pcb.tos.node ) then
			return pcb.tos.node;
        endif;

        return pcb.ret;
endfunction
#endregion

#region epilogue
@@epilogue
#endregion

parse("1 + 1");

</file>
</generator>
